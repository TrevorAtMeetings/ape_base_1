Key Issues & Errors Revealed:
Extrapolation/Interpolation Failures (Still Dominant):
WARNING:app.performance_calculator:Target value 342.0 far outside curve range [0.0, 191.7] with tolerance
WARNING:app.performance_calculator:Interpolation failed for pump 5 K at flow 342.0 - failed: ['head', 'efficiency', 'power', 'npshr']
WARNING:app.performance_calculator:No suitable curve found for 5 K
Analysis: The input flow of 342.0 m³/hr is significantly outside the defined curve ranges for some pumps (e.g., "5 K" pump whose curves might end at 191.7 or 300 m³/hr).
The "with tolerance" suggests the 20% extrapolation margin might be in effect, but the target flow is still too far out.
When all interpolations fail for all curves of a given pump, No suitable curve found for [PUMP_MODEL] is logged.
Consequence: This leads to the operating_point for these pumps being None or an error dictionary.
'NoneType' object has no attribute 'get' in selection_engine (Recurring):
ERROR:app.selection_engine:Error generating reasoning: 'NoneType' object has no attribute 'get' (and similar for BEP, NPSH, Power analysis).
Analysis: This happens when evaluate_pump_for_requirements or find_best_curve_for_duty returns None (or an object that later becomes None or an error dictionary without the expected keys) because no valid operating point could be determined for a pump (due to issue #1). Subsequent code in selection_engine that expects a valid operating point dictionary then fails.
Your previous fix attempts need to be more robust here. The code that calls llm_reasoning.generate_technical_analysis or other analysis functions must strictly check if the evaluation or operating_point data is valid and complete before proceeding.
Jinja2 Template Error - 'dict object' has no attribute 'flow_m3hr' (NEW CRITICAL ERROR):
ERROR:app.routes:Error displaying pump report: 'dict object' has no attribute 'flow_m3hr'
jinja2.exceptions.UndefinedError: 'dict object' has no attribute 'flow_m3hr'
This error occurs when rendering templates/pump_report.html (or results_page.html if that's where line 181 is).
The template is trying to access selected_pump.operating_point.flow_m3hr.
Analysis:
The selected_pump object being passed to the template (which is suggested_pump_obj in app/routes.py for results_page.html, or a similar object for pump_report.html) is expected to have an operating_point attribute, which itself is an object with a flow_m3hr attribute.
The error means that selected_pump.operating_point is a dictionary, not an object, and thus you should use dictionary access selected_pump.operating_point['flow_m3hr'] or selected_pump.operating_point.get('flow_m3hr').
OR, selected_pump itself is a dictionary, and the template should use selected_pump['operating_point']['flow_m3hr'].
OR, even more likely, the operating_point within top_selections[0] (which is what suggested_pump is based on) is already the dictionary calculated by calculate_operating_point.
Looking at your pump_engine.py and the structure of top_selections items (which include an operating_point dictionary), the issue is likely in how suggested_pump_obj (which is a ParsedPumpData instance) is being conflated with the operating_point data associated with it in the top_selections list.
The template_data passed to results_page.html includes:
template_data = {
    # ...
    'top_selections': top_selections, # List of dicts, each dict has an 'operating_point' dict
    'suggested_pump': suggested_pump_obj, # This is a ParsedPumpData object
    # ...
}
Use code with caution.
Python
In results_page.html, you access top_selections[0].operating_point.flow_m3hr which is correct because top_selections[0] is a dictionary.
However, if pump_report.html (the one crashing at line 181) is receiving just selected_pump (which might be suggested_pump_obj which is a ParsedPumpData instance) and also a separate operating_point dictionary, the template needs to be consistent. If pump_report.html is meant to display the selected pump's operating point, it should use the operating_point data from the corresponding entry in top_selections.
Debugging & Refinement Instructions for the Agent:
Robust Handling of Out-of-Range Flow & Failed Interpolation (Revisit & Strengthen):
Instruction to Agent: "In app.performance_calculator.interpolate_value and app.performance_calculator.calculate_operating_point:
Ensure that if a flow is outside the extrapolation limits (e.g., beyond +/- 20% of the curve's defined range), interpolate_value returns a clear indicator of failure (e.g., None or {'error': 'Out of extrapolation range'}).
calculate_operating_point must check the return from each call to interpolate_value. If any essential value (head, efficiency) cannot be determined, calculate_operating_point should return a dictionary clearly flagging an error (e.g., {'error': 'Cannot determine operating point at this flow', 'achieved_head_m': None, ...}).
It should also return an extrapolated: True flag if extrapolation was used successfully."
Robust Error Handling in selection_engine.py (Revisit & Strengthen):
Instruction to Agent: "In app.selection_engine.py (specifically in evaluate_pump_for_requirements and any functions that perform BEP, NPSH, power analysis, or prepare data for llm_reasoning):
Before attempting any analysis or calling the LLM, rigorously check if the operating_point data received from calculate_operating_point is valid and complete (i.e., no error flag, essential metrics are not None).
If the operating_point is invalid, that pump/curve combination should be heavily penalized or excluded from being a 'suitable pump.' No LLM calls should be made for invalid operating points.
This will prevent the 'NoneType' object has no attribute 'get' errors."
Fix Template Variable Access for Operating Point (CRITICAL for pump_report.html):
Instruction to Agent: "The error jinja2.exceptions.UndefinedError: 'dict object' has no attribute 'flow_m3hr' in templates/pump_report.html (line 181) indicates an issue with how the operating point data is accessed."
"Review the data being passed to pump_report.html when the /generate_pdf/<pump_code> route (or whichever route renders pump_report.html) is called."
"If selected_pump is a ParsedPumpData object and operating_point is a separate dictionary passed to the template, then access should be operating_point.flow_m3hr or operating_point['flow_m3hr']."
"If the operating_point dictionary is nested within selected_pump (e.g., selected_pump.calculated_op = {'flow_m3hr': ...}), then access would be selected_pump.calculated_op.flow_m3hr or selected_pump.calculated_op['flow_m3hr']."
"Most likely, the operating_point data should be sourced from the corresponding entry in the top_selections list that was generated by find_best_pumps. Ensure that the data structure passed to pump_report.html allows for accessing the operating point details correctly. For example, you might pass selected_pump_details = top_selections[0] to the template, and then access selected_pump_details.operating_point.achieved_flow_m3hr (if operating_point is an object) or selected_pump_details['operating_point']['achieved_flow_m3hr'] (if operating_point is a dict)."
Standardize: Ensure that the results_page.html and pump_report.html (and the data passed to them) handle the selected pump and its operating point data consistently. The structure used in top_selections (where each item is a dict containing pump_code, model, manufacturer, operating_point dict, overall_score, etc.) is a good model. suggested_pump in results_page.html should likely be top_selections[0], not a separate ParsedPumpData object without the context of the calculated operating point.
Conditional LLM Calls:
Instruction to Agent: "In app.selection_engine.find_best_pumps or where LLM reasoning is generated: only make LLM API calls for pumps that have a fully valid and determined operating point. If a pump's operating point could not be calculated due to out-of-range flow, skip LLM reasoning for that pump."
Review generate_pump_charts in app/routes.py:
Instruction to Agent: "The generate_pump_charts function still appears to be using dummy data for plotting:
# Sample data for demonstration
x = np.linspace(0, 200, 50)
y = 50 - 0.001 * x**2  # Simple parabolic head curve
ax.plot(x, y, 'b-', linewidth=2, label='Head Curve')
Use code with caution.
Python
This must be replaced with logic to plot the actual curve data from parsed_pump_obj.curves (e.g., parsed_pump_obj.curves[operating_point['curve_index']]['flow_vs_head']).
Ensure all four charts (Head, Efficiency, Power, NPSH) are generated using actual data.
By focusing on these areas, the agent should be able to make the application much more robust to varying input requirements and correctly display information in the templates. The Jinja2 error is a straightforward data access issue that needs to be fixed by aligning the template with the structure of the data being passed from the Python backend.