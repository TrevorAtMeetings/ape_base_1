The Vision:
Instead of a feature_toggle_service.py that queries a database, we will have a method in the AdminConfigService that reads feature toggles from a configuration file or a simple dictionary.
The Brain (and other parts of the app) will ask the AdminConfigService if a feature is enabled.
This keeps all "tunable" aspects of the application in one manageable place.
Action Plan: Migrating to a Config-Based Feature Toggle System
Here is a step-by-step plan to implement this superior, database-free approach.
Step 1: Remove the Broken feature_toggle_service.py
Action: Delete the file app/feature_toggle_service.py. Its functionality is being moved to a better location, and its current state is causing errors. This is a critical first step to stop the bleeding.
Step 2: Define Feature Toggles in a Configuration File
Action: We will define the feature toggles in a simple, easy-to-edit format. We can create a new configuration file for this.
File to create: config/features.json (create the config/ directory if it doesn't exist).
code
Json
{
  "enable_ai_analysis": {
    "description": "Enables the AI Technical Analysis section on the report page.",
    "enabled": true
  },
  "enable_comparison_feature": {
    "description": "Allows users to add pumps to a shortlist and compare them.",
    "enabled": true
  },
  "use_advanced_bep_migration": {
    "description": "Uses the Hydraulic Institute model for BEP shift calculations. Disable for legacy affinity laws.",
    "enabled": true
  },
  "enable_bep_proximity_search": {
    "description": "Shows the 'BEP Proximity Search' tab on the main selection page.",
    "enabled": false
  }
}
This JSON file is now the single source of truth for which features are active.
Step 3: Enhance AdminConfigService to Read This File
File to modify: app/admin_config_service.py
Action: Add new methods to this service to load and provide access to the feature toggles.
code
Python
# In app/admin_config_service.py

import json
from functools import lru_cache

class AdminConfigService:
    # ... (existing __init__ method) ...

    @lru_cache(maxsize=1) # Cache the feature flags in memory
    def _load_feature_toggles(self):
        """Loads feature toggles from the JSON config file."""
        try:
            # Assuming your config folder is at the root
            with open('config/features.json', 'r') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            logger.error("Could not load config/features.json. Returning empty toggles.")
            return {}

    def get_feature_toggles(self):
        """Returns the full dictionary of feature toggles."""
        return self._load_feature_toggles()

    def is_feature_enabled(self, feature_name: str) -> bool:
        """Checks if a specific feature is enabled."""
        toggles = self._load_feature_toggles()
        feature = toggles.get(feature_name)
        if feature:
            return feature.get('enabled', False)
        return False # Default to false if the feature is not defined
Step 4: Refactor the Application to Use the New Service
Action: Now, we need to find all the places that were calling the old feature_toggle_service and make them call the new AdminConfigService instead.
The primary location is the /api/features/status endpoint.
File to modify: app/route_modules/api.py (or wherever /api/features/status is located).
code
Python
# In api.py

from ..admin_config_service import get_config_service # Import the service

@api_bp.route('/api/features/status')
def features_status():
    try:
        config_service = get_config_service()
        toggles = config_service.get_feature_toggles()
        return jsonify(toggles)
    except Exception as e:
        logger.error(f"Error getting feature status: {e}")
        return jsonify({"error": "Could not retrieve feature status"}), 500
Summary of Benefits
This approach is vastly superior to the database method:
No Database Changes: Exactly as you requested.
Version Controllable: The features.json file can be checked into Git. This means you can see the history of when features were turned on or off directly in your commit history.
Simple and Fast: Reading from a local JSON file is much faster than making a database query. The @lru_cache ensures it only happens once.
Fits the Brain Architecture: It centralizes configuration within the existing AdminConfigService, which aligns perfectly with your goal of having a single, manageable source of truth for all application logic and configuration.
This is the right path forward. It solves the error, avoids unnecessary database complexity, and improves your overall architecture.