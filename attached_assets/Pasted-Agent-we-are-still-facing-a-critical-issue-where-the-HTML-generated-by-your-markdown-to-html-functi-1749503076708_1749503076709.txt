Agent, we are still facing a critical issue where the HTML generated by your markdown_to_html function (in app/routes.py or its new location) results in all or most of the content being styled as if it's part of the first <h4> header. We need to ensure proper HTML structure with distinct headers, paragraphs, and lists.
Please meticulously review and refactor markdown_to_html and its helper process_section_content with the following strategy:
Isolate and Test process_section_content:
Action: Temporarily, let's ensure this function is robust. Give it a simple multi-line input string (that does not start with ##) and verify its output.
# Example test for process_section_content
test_content = "This is the first paragraph.\n\nThis is the second paragraph with **bold text** and *italic text*.\n\n- Item 1\n- Item 2\n  - Sub Item 2.1"
html_output = process_section_content(test_content)
logger.debug(f"process_section_content INPUT:\n{test_content}")
logger.debug(f"process_section_content OUTPUT:\n{html_output}")
Use code with caution.
Python
Expected Output: It should produce <p>...</p><p>...</p><ul><li>...</li></ul>.
Focus: Ensure that paragraphs are correctly wrapped in <p> tags and that lists are correctly transformed into <ul><li>...</li></ul>. Ensure bold/italics are correctly applied within these structures.
Fix: Modify process_section_content to ensure every distinct block of text (separated by one or more blank lines in the input markdown) becomes a separate <p> tag, and lines starting with - become list items within a <ul>.
Refine markdown_to_html Sectioning and Content Association:
Action: Review the main markdown_to_html function.
The current split re.split(r'^## ', text, flags=re.MULTILINE) means sections is content before the first ##. sections starts with the first H4 title text, then its content.
Proposed Logic Refinement for the Loop:
# Conceptual refinement for markdown_to_html
# ... (text cleanup at the start) ...
# Split by the ## marker, keeping the marker to identify headers
# Use a regex that captures the header line and the content that follows

# Alternative: Find all headers first
header_matches = list(re.finditer(r'^##\s*(.+?)\s*$', text, flags=re.MULTILINE))
html_output_parts = []

last_end = 0
if not header_matches and text.strip(): # Handle text with no "##" headers
     html_output_parts.append(f"<div class='md-section'>{process_section_content(text.strip())}</div>")

for i, match in enumerate(header_matches):
    header_text = match.group(1).strip()
    start_of_content = match.end()
    
    # Content before this header (if it's the first header and there's preceding text)
    if i == 0 and match.start() > 0:
        pre_content = text[0:match.start()].strip()
        if pre_content:
            html_output_parts.append(f"<div class='md-section'>{process_section_content(pre_content)}</div>")

    # Generate H4 tag (ensure it's properly closed before content)
    # Example of numbered header:
    numbered_header_text = f"{i+1}) {header_text}" # Or use the number if already in header_text
    h4_tag = f'<h4 style="color: #1976d2; margin: 20px 0 10px 0; font-weight: 600;">{numbered_header_text}</h4>'
    
    # Get content for this section
    if i + 1 < len(header_matches):
        content_for_section = text[start_of_content:header_matches[i+1].start()].strip()
    else:
        content_for_section = text[start_of_content:].strip()

    processed_content = process_section_content(content_for_section)
    
    html_output_parts.append(f"<div class='md-section'>{h4_tag}{processed_content}</div>")
    last_end = match.end() # Not used in this specific loop but good for other patterns

return "".join(html_output_parts)
```    *   **Key Idea:** For each `## Header`, create an `<h4>` tag. Then, take all the text *between that header and the next `## Header` (or end of document)* and pass *that specific chunk* to `process_section_content`. Ensure each resulting `<h4>` and its processed content are wrapped in a containing `div` that is properly closed before the next section starts.
Use code with caution.
Python
CSS Over Inline Styles (Recommendation):
Action: "While fixing, please try to move inline styles like style=\"color: #1976d2; ...\" from the generated HTML into CSS classes (e.g., .md-h4, .md-section, .md-paragraph, .md-list-item) defined in static/css/style.css. This will make the generated HTML cleaner and styling easier to manage."
Example generated H4: <h4 class="md-h4">1) Efficiency Characteristics...</h4>
Example CSS: .md-h4 { color: #1976d2; margin: 20px 0 10px 0; font-weight: 600; }
Provide Sample Input and Output for Debugging:
Action: "Agent, to help you debug this, use the following sample markdown text as input to your revised markdown_to_html function and log the exact HTML output it produces:
## 1) First Section Title
This is the first paragraph of the first section.
It might have **bold** and *italic* text.

This is another paragraph in the first section.

## 2) Second Section Title
This section only has one paragraph.

- Followed by a list
- Item two
Use code with caution.
Markdown
Expected HTML (Conceptual):
<div class="md-section">
    <h4 class="md-h4">1) First Section Title</h4>
    <p class="md-paragraph">This is the first paragraph of the first section. It might have <strong class="md-bold">bold</strong> and <em class="md-italic">italic</em> text.</p>
    <p class="md-paragraph">This is another paragraph in the first section.</p>
</div>
<div class="md-section">
    <h4 class="md-h4">2) Second Section Title</h4>
    <p class="md-paragraph">This section only has one paragraph.</p>
    <ul class="md-ul">
        <li class="md-li">Followed by a list</li>
        <li class="md-li">Item two</li>
    </ul>
</div>
Use code with caution.
Html
After implementing and testing these changes with the sample markdown:
Test with the actual LLM output that was causing the problem (the long text snippet starting with <h4 style="...">1) Efficiency Characteristics...</h4>). The initial HTML tag stripping text = re.sub(r'<[^>]+>', '', text) in markdown_to_html is important if the LLM itself is outputting HTML, but the primary goal is to parse the markdown ## headers.
Verify in the browser that the content is now correctly structured with distinct H4s followed by properly formatted paragraphs and lists, and that the styling is correct.
This more structured approach to parsing headers and then processing the content between them should resolve the issue of everything appearing under the first header's style.