Priority Issues (By Severity)
ðŸŸ¥ Critical Bug
Flawed Interpolation Due to Unsorted Data:
Location: app/brain/performance.py -> calculate_at_point
Problem: The code extracts flows, heads, effs, and powers into separate lists. It then creates a sorted_data tuple but never actually uses it to sort the original lists. The subsequent calls to interpolate.interp1d are still using the original, potentially unsorted lists.
Impact: scipy.interpolate.interp1d requires that the x-axis data (the flows list) be monotonically increasing. If the data points in your database are not stored in perfect ascending order of flow, the interpolation will fail, likely returning NaN (Not a Number). This NaN then propagates through the calculations, causing the np.isnan(...) check to correctly (but silently) fail the pump. This is almost certainly the root cause of the "0 results" issue.
Recommendation: You must use the sorted data to perform the interpolation.
The Fix:
code
Python
# In calculate_at_point method

# ... after extracting flows, heads, effs, powers ...

# CRITICAL FIX: Sort the data points based on flow before interpolation
try:
    sorted_points = sorted(zip(flows, heads, effs, powers), key=lambda p: p[0])
    flows_sorted, heads_sorted, effs_sorted, powers_sorted = zip(*sorted_points)
except ValueError:
    # This happens if any of the lists are empty
    logger.debug(f"[PERF] {pump_code}: Curve {i+1} skipped - empty data lists after extraction.")
    continue

# Now use the GUARANTEED sorted lists for interpolation
head_interp = interpolate.interp1d(flows_sorted, heads_sorted, ...)
eff_interp = interpolate.interp1d(flows_sorted, effs_sorted, ...)
power_interp = interpolate.interp1d(flows_sorted, powers_sorted, ...)
ðŸŸ¨ High-Priority Issues
Unsafe Handling of Missing Power Data:
Location: app/brain/performance.py -> calculate_at_point
Problem: The code correctly identifies that it should never invent power data. It appends None to the powers list if a value is missing. However, interpolate.interp1d cannot handle None values in its input arrays. It will raise a TypeError.
Impact: Any pump curve that is missing even a single power data point will cause an exception inside the try...except block, causing that entire curve to be skipped. Given the state of the data, this could be happening frequently.
Recommendation: Before attempting to interpolate power, check if the powers_sorted list contains any None values. If it does, you cannot interpolate power for that curve. The power should be calculated later using the hydraulic formula, which is a sound engineering fallback.
The Fix:
code
Python
# In calculate_at_point method, after sorting the data

delivered_head = float(head_interp(flow))
efficiency = float(eff_interp(flow))

# Check if power can be interpolated
if None in powers_sorted:
    # Cannot interpolate, calculate power hydraulically instead
    power = self._calculate_hydraulic_power(flow, delivered_head, efficiency)
    logger.debug(f"[PERF] {pump_code}: Power data incomplete. Calculated hydraulically: {power:.2f} kW")
else:
    # Safe to interpolate
    power_interp = interpolate.interp1d(flows_sorted, powers_sorted, ...)
    power = float(power_interp(flow))
Duplicate and Confusing Debug Code:
Location: app/brain/performance.py -> calculate_at_point
Problem: There is a hardcoded if pump_code == "150-400 2F": check. There is also a duplicate if not (min_flow * 0.9 <= flow <= max_flow * 1.1): continue block nested inside it.
Impact: This makes the code confusing and hard to maintain. The duplicate check is redundant.
Recommendation: Remove the entire hardcoded if pump_code == ... block and the duplicate logic inside it. The generic debug logging you've added is sufficient.
Inaccurate NPSH Interpolation:
Location: app/brain/performance.py -> calculate_at_point
Problem: The NPSH interpolation logic is good, but it's using the original, potentially unsorted flows list, which will lead to the same NaN or error results as the head/efficiency interpolation.
Impact: NPSH values will be incorrect or cause crashes.
Recommendation: The NPSH interpolation must also use the flows_sorted list that was created at the beginning of the try block.
Summary of Recommendations
The PerformanceAnalyzer is the most complex piece of the Brain. It's 95% of the way there, but these data handling and interpolation bugs are preventing it from working reliably.
FIX (Critical): Always sort the curve data by flow before passing it to scipy.interpolate.interp1d. This will fix the NaN errors.
FIX (High): Handle missing power data gracefully. Check for None values before attempting to interpolate power and use the hydraulic power formula as a fallback.
CLEANUP (High): Remove the hardcoded debug block and the duplicate flow range check.
FIX (Medium): Ensure the NPSH interpolation also uses the sorted flow data.
By implementing these fixes, you will resolve the "silent failure" bug, and the performance module will start returning valid calculations. This will, in turn, allow the SelectionIntelligence module to correctly score and rank the pumps, and you will finally see meaningful results in the UI.