Objective: Evolve the selection engine into a true "Best Fit" system. The system will first intelligently prioritize pumps based on their BEP proximity to the duty point, and then run a comprehensive evaluation to find the absolute best configuration for each pump. This ensures we find the most optimal engineering solution in the most efficient manner.
Do not code yet. Review this three-phase plan first.
Phase 1: Critical Bug Fixes - Ensure Correctness (Highest Priority)
Problem: The frontend charts.js file is currently applying incorrect calculations and displaying misleading data to the user. This is a blocking issue that undermines trust in the entire system.
File to Modify: static/js/charts.js
Instructions:
Fix Double Application of Affinity Laws:
In all render...Chart functions, locate and remove any lines of code that re-calculate or re-scale the operating_point coordinates (opPoint.flow_m3hr, opPoint.head_m, etc.).
The frontend must plot the operating_point using the exact coordinates provided by the backend API. The backend has already performed the necessary scaling.
Fix Incorrect URL Encoding:
In the loadChartData function, replace the incorrect btoa() encoding with the web-standard encodeURIComponent().
Change from: const safePumpCode = btoa(pumpCode).replace(...)
Change to: const safePumpCode = encodeURIComponent(pumpCode);
Refactor for Maintainability (Recommended):
Identify the heavily duplicated code blocks across the four render...Chart functions (e.g., layout creation, legend configuration).
Create shared helper functions to handle this logic, reducing redundancy and making future changes easier.
Phase 2: Core Logic Upgrade - Implement the "Best Fit" Algorithm
Problem: The current backend algorithm uses a "First Fit" approach, returning the first viable solution it finds for a pump, which is often not the best one.
File to Modify: app/catalog_engine.py
Instructions:
Refactor get_performance_at_duty():
The function must be changed to not return immediately after finding one valid solution.
New Logic:
a. Initialize an empty list, possible_solutions.
b. Sequentially evaluate all possible methods (Direct, Extrapolation, Trim, Speed Variation).
c. For every method that produces a valid result, calculate its full score (including penalties) and add the complete solution object (performance data + score) to the possible_solutions list.
d. After all methods have been tried, check the possible_solutions list.
e. If the list is empty, return None.
f. If the list contains one or more solutions, return the single solution with the highest total score.
Phase 3: Performance Optimization - Implement BEP-Centric Pre-Sorting
Problem: Evaluating all 386 pumps with the comprehensive "Best Fit" logic can be computationally expensive. We can significantly improve performance by evaluating the most likely candidates first.
File to Modify: app/catalog_engine.py
Instructions:
Refactor select_pumps_with_ranking():
This is the master function that loops through all pumps.
New Logic:
a. Before the main loop begins, get the full list of all pump objects.
b. Perform a pre-sort on this list. The sort key should be the absolute difference between the pump's nominal QBEP and the user's required flow: abs(pump.q_bep - site_requirements.flow_m3hr).
c. Crucially, do not filter or discard any pumps. This is a sort, not a filter.
d. Proceed with the main loop, iterating through the now pre-sorted list of pumps. Run the full "Best Fit" evaluation (get_performance_at_duty) on each one.
This new, three-phase approach ensures we first fix what the user sees, then fix the core backend logic to be truly "Best Fit," and finally optimize the process using your intelligent BEP-centric pre-sorting strategy.
Your first task is to execute Phase 1. Please proceed with fixing the bugs in static/js/charts.js. Show me the diff when you are complete.